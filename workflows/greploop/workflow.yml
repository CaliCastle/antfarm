id: greploop
name: PR Review Fix Loop
version: 1
description: |
  Automated PR review remediation loop. Fetches unresolved review threads,
  classifies them (bot vs human, actionable vs discussion), fixes the code,
  resolves threads, re-requests reviews, and loops until clean.
  Supports Greptile, CodeRabbit, Copilot, and human reviewers.

polling:
  model: kimi-coding/k2p5
  timeoutSeconds: 120

agents:
  - id: fetcher
    name: Thread Fetcher
    role: analysis
    description: Fetches unresolved PR review threads and classifies them.
    timeoutSeconds: 300
    model: kimi-coding/k2p5
    workspace:
      baseDir: agents/fetcher
      files:
        AGENTS.md: agents/fetcher/AGENTS.md
        SOUL.md: agents/fetcher/SOUL.md
        IDENTITY.md: agents/fetcher/IDENTITY.md

  - id: fixer
    name: Code Fixer
    role: coding
    description: Fixes all actionable review comments, builds, commits, pushes.
    timeoutSeconds: 1800
    model: openai-codex/gpt-5.3-codex
    workspace:
      baseDir: agents/fixer
      files:
        AGENTS.md: agents/fixer/AGENTS.md
        SOUL.md: agents/fixer/SOUL.md
        IDENTITY.md: agents/fixer/IDENTITY.md

  - id: resolver
    name: Thread Resolver
    role: pr
    description: Resolves bot threads, replies to human threads, re-requests reviews.
    timeoutSeconds: 600
    model: openai-codex/gpt-5.3-codex
    workspace:
      baseDir: agents/resolver
      files:
        AGENTS.md: agents/resolver/AGENTS.md
        SOUL.md: agents/resolver/SOUL.md
        IDENTITY.md: agents/resolver/IDENTITY.md

  - id: reporter
    name: Reporter
    role: analysis
    description: Posts summary report and triggers re-review.
    timeoutSeconds: 300
    model: anthropic/claude-opus-4-6
    workspace:
      baseDir: agents/reporter
      files:
        AGENTS.md: agents/reporter/AGENTS.md
        SOUL.md: agents/reporter/SOUL.md
        IDENTITY.md: agents/reporter/IDENTITY.md

steps:
  - id: fetch
    agent: fetcher
    input: |
      Fetch and classify all unresolved review threads on a PR.

      TASK:
      {{task}}

      Instructions:
      1. Parse PR reference from the task (owner/repo#N or repo path + PR number)
      2. Clone or update the local repo under ~/Projects/<repo-name>
      3. Check out the PR's head branch and pull latest
      4. Use GraphQL to fetch ALL unresolved review threads with full comment bodies
      5. Classify each thread:
         - Bot (greptileai, greptile-apps, coderabbitai, github-actions, copilot, ends with [bot]): actionable, auto-resolve after fix
         - Human actionable (imperative language, suggestions, code changes requested): actionable, reply-only after fix
         - Human question/discussion (questions, "should we", "what about"): skip, needs human input
      6. Output the full classification

      GraphQL query to use:
      ```
      gh api graphql -f query='
      query($owner:String!, $repo:String!, $pr:Int!) {
        repository(owner:$owner, name:$repo) {
          pullRequest(number:$pr) {
            headRefName
            reviewThreads(first:100) {
              nodes {
                id
                isResolved
                line
                path
                comments(first:20) {
                  nodes {
                    id
                    databaseId
                    body
                    author { login }
                    createdAt
                  }
                }
              }
            }
          }
        }
      }' -f owner="$OWNER" -f repo="$REPO" -F pr=$PR
      ```

      Reply with:
      STATUS: done
      OWNER: github org/owner
      REPO_NAME: repo name (just the name, not owner/name)
      PR_NUMBER: the PR number
      BRANCH: the head branch name
      REPO_PATH: local path to repo
      THREADS_JSON: JSON array of classified threads, each with: { threadId, path, line, classification (bot|human_fix|human_question), author, body, databaseId (of first comment) }
      BOT_COUNT: number of bot threads
      HUMAN_FIX_COUNT: number of human actionable threads
      HUMAN_QUESTION_COUNT: number of human question/discussion threads
      REVIEWERS: comma-separated list of unique human reviewers who left actionable comments

      If zero unresolved threads, reply:
      STATUS: clean
      (and include OWNER, REPO_NAME, PR_NUMBER, BRANCH, REPO_PATH with empty THREADS_JSON: [])
    expects: "STATUS:"
    max_retries: 2
    on_fail:
      escalate_to: human

  - id: fix
    agent: fixer
    input: |
      Fix all actionable review comments on this PR.

      TASK: {{task}}
      OWNER: {{owner}}
      REPO_NAME: {{repo_name}}
      PR_NUMBER: {{pr_number}}
      BRANCH: {{branch}}
      REPO_PATH: {{repo_path}}

      THREADS TO FIX (JSON):
      {{threads_json}}

      Instructions:
      1. cd into {{repo_path}}, ensure you're on {{branch}} and up to date
      2. For EACH actionable thread (classification: bot or human_fix):
         - Read the file at the specified path
         - Apply the requested change
         - If the thread includes a GitHub suggestion block, apply it exactly
      3. After ALL fixes:
         - Detect build tool from package.json (pnpm build / npm run build / npx tsc --noEmit)
         - Run the build and fix any issues
         - Commit: fix: address PR review feedback
         - Push to origin/{{branch}}
      4. Get the commit hash: git log --oneline -1

      Reply with:
      STATUS: done
      COMMIT: the short commit hash
      CHANGES: summary of what was changed

      If no actionable threads (all were questions):
      STATUS: skip
      CHANGES: no actionable threads to fix
    expects: "STATUS:"
    max_retries: 2
    on_fail:
      escalate_to: human

  - id: resolve
    agent: resolver
    input: |
      Resolve threads and reply to human comments on the PR.

      OWNER: {{owner}}
      REPO_NAME: {{repo_name}}
      PR_NUMBER: {{pr_number}}
      BRANCH: {{branch}}
      COMMIT: (get from git log in REPO_PATH â€” run: cd REPO_PATH && git log --oneline -1)
      CHANGES: {{changes}}

      THREADS (JSON):
      {{threads_json}}

      REVIEWERS: {{reviewers}}

      Instructions:
      For each thread in THREADS_JSON:

      1. Bot threads (classification: bot) -> resolve via GraphQL:
         gh api graphql -f query='mutation($id:ID!) { resolveReviewThread(input:{threadId:$id}) { thread { isResolved } } }' -f id="THREAD_ID"

      2. Human actionable threads (classification: human_fix) -> resolve via GraphQL (same as bot) AND reply with commit hash:
         gh api -X POST repos/{{owner}}/{{repo_name}}/pulls/comments/DATABASE_ID/replies -f body='Fixed in COMMIT. @AUTHOR please verify.'

      3. Human question threads (classification: human_question) -> SKIP, do not resolve or reply.

      After resolving/replying to all threads:
      4. Re-request review from ALL human reviewers:
         gh pr edit {{pr_number}} --repo {{owner}}/{{repo_name}} --add-reviewer REVIEWER1,REVIEWER2

      Reply with:
      STATUS: done
      RESOLVED_COUNT: number of threads resolved
      REPLIED_COUNT: number of human threads replied to
      SKIPPED_COUNT: number of threads skipped (questions)
      SKIPPED_THREADS: list of skipped threads (author, path, truncated body) or "none"
    expects: "STATUS: done"
    max_retries: 2
    on_fail:
  - id: report
    agent: reporter
    input: |
      Post summary and trigger re-review.

      OWNER: {{owner}}
      REPO_NAME: {{repo_name}}
      PR_NUMBER: {{pr_number}}
      REPO_PATH: {{repo_path}}
      BRANCH: {{branch}}

      Instructions:
      1. cd into REPO_PATH and get latest commit: git log --oneline -1
      2. Check current thread status on the PR:
         gh api graphql to count resolved vs unresolved threads
      3. Trigger Greptile re-review:
         gh pr comment PR_NUMBER --repo OWNER/REPO_NAME --body "@greptileai review"
      4. Build a summary of what happened this round.

      Reply with:
      STATUS: done
      SUMMARY: a clean multi-line summary suitable for Slack
    expects: "STATUS: done"
    on_fail:
      escalate_to: human
